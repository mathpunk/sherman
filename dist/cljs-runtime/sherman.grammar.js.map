{"version":3,"file":"sherman.grammar.js","sources":["sherman/grammar.cljs"],"mappings":";;;;AAMA,AAAKA,0BAAQ,uGAAA,mDAAA,zJAACC,oDAAAA,uEAAAA;AAGd,0BAAA,1BAAMC,4DAASC;AAAf,AACE,IAAMC,eAAa,AAAgBJ,sCAAQ,AAACK,qBAAQF;AAApD,AACE,AAAeC,0BAAa,AAAoBJ;;AAChDI;;AAGJ;;;;;wBAAA,xBAAME,wDAIHH,MAAMI;AAJT,AAKE,OAAU,AAACL,wBAAQC,eAAO,CAAA,+DAAA,fAASI;;AAGrC,AAAA,wBAAA,gCAAAC,xDAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,2DAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,AAAA,AAAAE,6DAAA,WAAaX,MAAQgB;AAArB,AACE,IAAMC,oBAAkB,AAACC,cAAIF;IACvBG,gBAAc,6CAAK,AAACC;IACpBC,iBAAe,AAACC,8CAAMtB,MAAMmB,cAAcF;AAFhD,AAGE,OAACd,sBAAMkB,eAAeF;;;AAJ1B,AAAA,AAAAR,gDAAA;;AAAA,AAAA,AAAAA,0CAAA,WAAAC;AAAA,AAAA,IAAAC,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,OAAAD,2DAAAE,SAAAD;;;AAAA","names":["sherman.grammar/tracery","cljs.nodejs/require","sherman.grammar/grammar","rules","base-grammar","cljs.core/clj->js","sherman.grammar/trace","template-name","var_args","args__6412__auto__","len__6405__auto__","i__6406__auto__","argseq__6413__auto__","cljs.core/IndexedSeq","sherman.grammar/apply","seq32019","G__32020","cljs.core/first","cljs.core/next","templates","sentence-patterns","cljs.core/vec","sentence-name","cljs.core.gensym.cljs$core$IFn$_invoke$arity$0","complete-rules","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3"],"sourcesContent":["(ns sherman.grammar\n  (:refer-clojure :exclude [apply])\n  (:require [cljs.nodejs :as nodejs]\n            [cljs.spec.alpha :as s]))\n\n\n(def tracery (nodejs/require \"tracery-grammar\"))\n\n\n(defn grammar [rules]\n  (let [base-grammar (.createGrammar tracery (clj->js rules))]\n    (.addModifiers base-grammar (.-baseEngModifiers tracery))\n    base-grammar))\n\n\n(defn trace\n  \"Generate a sentence from rules and a template name. Note, this is different\n  from making a generator that you then act on, which could be an okay interface\n  too.\"\n  [rules template-name]\n  (.flatten (grammar rules) (str \"#\" template-name \"#\")))\n\n\n(defn apply [rules & templates]\n  (let [sentence-patterns (vec templates)\n        sentence-name (str (gensym))\n        complete-rules (assoc rules sentence-name sentence-patterns)]\n    (trace complete-rules sentence-name)))\n"]}